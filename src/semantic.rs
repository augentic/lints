//! Semantic analysis for Omnia code.
//!
//! This module provides deeper code analysis beyond simple pattern matching,
//! including:
//! - Provider trait bound analysis (detecting unused or missing bounds)
//! - Trait usage tracking
//! - Handler implementation validation
//! - Transitive trait detection through function delegation
//!
//! The extraction layer uses `syn` for AST-based parsing, making it robust
//! against false positives from string literals, comments, and multi-line
//! formatting. The analysis logic (transitive resolution, diagnostic
//! generation) operates on the extracted data structures.

use std::collections::{HashMap, HashSet};

use regex::Regex;
use syn::spanned::Spanned;
use syn::visit::Visit;
use syn::{Expr, ExprAwait, ExprField, ExprMethodCall, ExprPath, Item};

use crate::diagnostics::Diagnostic;
use crate::rules::{RuleCategory, RuleSeverity};

/// Information about a helper function with provider bounds.
#[derive(Debug, Clone)]
pub struct FunctionInfo {
    /// Name of the function.
    pub name: String,

    /// Line number where the function starts (0-indexed).
    pub line: usize,

    /// Provider trait bounds declared on the function.
    pub declared_bounds: HashSet<String>,

    /// Provider traits directly used in the function body.
    pub direct_trait_usage: HashSet<String>,

    /// Functions called from within this function.
    pub called_functions: HashSet<String>,

    /// Line range of the function.
    pub line_range: (usize, usize),
}

/// Result of semantic analysis for a document.
#[derive(Debug, Default)]
pub struct SemanticAnalysisResult {
    /// Diagnostics generated by semantic analysis.
    pub diagnostics: Vec<Diagnostic>,

    /// Handler implementations found in the document.
    pub handlers: Vec<HandlerInfo>,

    /// Provider trait usages detected.
    pub trait_usages: HashMap<String, Vec<TraitUsage>>,
}

/// Information about a Handler implementation.
#[derive(Debug, Clone)]
pub struct HandlerInfo {
    /// Name of the request type implementing Handler.
    pub request_type: String,

    /// Line number where the impl block starts (0-indexed).
    pub impl_line: usize,

    /// Provider trait bounds declared on the impl.
    pub declared_bounds: HashSet<String>,

    /// Provider traits actually used in the handler body (including transitive usage via delegation).
    pub used_traits: HashSet<String>,

    /// Provider traits directly used in the handler body (before transitive resolution).
    pub direct_trait_usage: HashSet<String>,

    /// Functions called from within this handler.
    pub called_functions: HashSet<String>,

    /// Line range of the impl block.
    pub line_range: (usize, usize),
}

/// A detected usage of a provider trait.
#[derive(Debug, Clone)]
pub struct TraitUsage {
    /// Name of the trait used.
    pub trait_name: String,

    /// Method called on the trait.
    pub method: String,

    /// Line number where the usage occurs (0-indexed).
    pub line: usize,

    /// Column range of the usage.
    pub col_range: (usize, usize),
}

// ---------------------------------------------------------------------------
// syn-based AST extraction
// ---------------------------------------------------------------------------

/// Check if a name is a known Omnia provider trait.
fn is_provider_trait(name: &str) -> bool {
    matches!(
        name,
        "Config" | "HttpRequest" | "Publisher" | "StateStore" | "Identity" | "TableStore"
    )
}

/// Extract the last segment name from a `syn::Path` (e.g. `omnia_sdk::Config` -> `"Config"`).
fn last_segment_name(path: &syn::Path) -> String {
    path.segments
        .last()
        .map(|s| s.ident.to_string())
        .unwrap_or_default()
}

/// Extract provider trait bounds from `syn::Generics` (inline + where clause).
fn extract_provider_bounds(generics: &syn::Generics) -> HashSet<String> {
    let mut bounds = HashSet::new();

    for param in &generics.params {
        if let syn::GenericParam::Type(type_param) = param {
            for bound in &type_param.bounds {
                if let syn::TypeParamBound::Trait(trait_bound) = bound {
                    let name = last_segment_name(&trait_bound.path);
                    if is_provider_trait(&name) {
                        bounds.insert(name);
                    }
                }
            }
        }
    }

    if let Some(where_clause) = &generics.where_clause {
        for predicate in &where_clause.predicates {
            if let syn::WherePredicate::Type(pred) = predicate {
                for bound in &pred.bounds {
                    if let syn::TypeParamBound::Trait(trait_bound) = bound {
                        let name = last_segment_name(&trait_bound.path);
                        if is_provider_trait(&name) {
                            bounds.insert(name);
                        }
                    }
                }
            }
        }
    }

    bounds
}

/// Extract a simple type name from `syn::Type` (handles `Path` types like `MyRequest`).
fn type_name(ty: &syn::Type) -> String {
    match ty {
        syn::Type::Path(tp) => last_segment_name(&tp.path),
        _ => String::new(),
    }
}

/// Check if an expression refers to `provider` or `ctx.provider`.
fn is_provider_receiver(expr: &Expr) -> bool {
    match expr {
        Expr::Path(ExprPath { path, .. }) => {
            path.segments.len() == 1 && path.segments[0].ident == "provider"
        }
        Expr::Field(ExprField { base, member, .. }) => {
            if let syn::Member::Named(ident) = member
                && ident == "provider"
                && let Expr::Path(ExprPath { path, .. }) = base.as_ref()
            {
                return path.segments.len() == 1 && path.segments[0].ident == "ctx";
            }
            false
        }
        // Handle &provider and &ctx.provider
        Expr::Reference(r) => is_provider_receiver(&r.expr),
        _ => false,
    }
}

/// Check if a method call expression is wrapped in `.await`.
/// In syn, `expr.await` is `ExprAwait { base: expr }`.
/// We check the parent context by looking at the call site instead.
/// Since we can't see the parent from the child during Visit, we detect
/// `.await` by checking if the method call is the base of an ExprAwait
/// that we track separately.
///
/// Instead, for StateStore vs Config disambiguation, we check whether the
/// method call appears inside an `.await` by scanning the impl block's content
/// textually for the specific pattern. This is a pragmatic hybrid approach.
fn method_to_trait(method: &str) -> Option<&'static str> {
    match method {
        "fetch" => Some("HttpRequest"),
        "send" => Some("Publisher"),
        "set" | "delete" => Some("StateStore"),
        "access_token" => Some("Identity"),
        "query" | "exec" => Some("TableStore"),
        _ => None,
    }
}

/// Visitor that walks expression trees to detect provider trait usage
/// and function calls for transitive resolution.
#[derive(Default)]
struct TraitUsageVisitor {
    used_traits: HashSet<String>,
    called_functions: HashSet<String>,
    trait_usages: Vec<TraitUsage>,
    /// Track expressions that are the base of an `.await`.
    /// We collect awaited method calls to disambiguate `provider.get` (Config vs StateStore).
    awaited_spans: HashSet<(usize, usize)>,
}

impl TraitUsageVisitor {
    /// First pass: collect all spans that are inside `.await` expressions.
    fn collect_awaited_spans(&mut self, items: &[syn::ImplItem]) {
        struct AwaitCollector {
            spans: HashSet<(usize, usize)>,
        }
        impl<'ast> Visit<'ast> for AwaitCollector {
            fn visit_expr_await(&mut self, node: &'ast ExprAwait) {
                let start = node.base.span().start();
                let end = node.base.span().end();
                self.spans.insert((start.line, start.column));
                let _ = end; // use start as the unique key
                syn::visit::visit_expr_await(self, node);
            }
        }
        let mut collector = AwaitCollector {
            spans: HashSet::new(),
        };
        for item in items {
            collector.visit_impl_item(item);
        }
        self.awaited_spans = collector.spans;
    }

    fn collect_awaited_spans_from_block(&mut self, block: &syn::Block) {
        struct AwaitCollector {
            spans: HashSet<(usize, usize)>,
        }
        impl<'ast> Visit<'ast> for AwaitCollector {
            fn visit_expr_await(&mut self, node: &'ast ExprAwait) {
                let start = node.base.span().start();
                self.spans.insert((start.line, start.column));
                syn::visit::visit_expr_await(self, node);
            }
        }
        let mut collector = AwaitCollector {
            spans: HashSet::new(),
        };
        collector.visit_block(block);
        self.awaited_spans = collector.spans;
    }

    fn is_awaited(&self, expr: &Expr) -> bool {
        let start = expr.span().start();
        self.awaited_spans.contains(&(start.line, start.column))
    }
}

impl<'ast> Visit<'ast> for TraitUsageVisitor {
    fn visit_expr_method_call(&mut self, call: &'ast ExprMethodCall) {
        let method = call.method.to_string();

        if is_provider_receiver(&call.receiver) {
            let line = call.method.span().start().line.saturating_sub(1);
            let col_start = call.method.span().start().column;
            let col_end = call.method.span().end().column;

            if method == "get" {
                // Disambiguate Config vs StateStore: .get(...).await -> StateStore
                let trait_name =
                    if self.is_awaited(&Expr::MethodCall(call.clone())) {
                        "StateStore"
                    } else {
                        "Config"
                    };
                self.used_traits.insert(trait_name.to_string());
                self.trait_usages.push(TraitUsage {
                    trait_name: trait_name.to_string(),
                    method: "get".to_string(),
                    line,
                    col_range: (col_start, col_end),
                });
            } else if let Some(trait_name) = method_to_trait(&method) {
                self.used_traits.insert(trait_name.to_string());
                self.trait_usages.push(TraitUsage {
                    trait_name: trait_name.to_string(),
                    method: method.clone(),
                    line,
                    col_range: (col_start, col_end),
                });
            }
        }

        syn::visit::visit_expr_method_call(self, call);
    }

    fn visit_expr_call(&mut self, call: &'ast syn::ExprCall) {
        if let Expr::Path(ExprPath { path, .. }) = call.func.as_ref() {
            let segments: Vec<String> = path.segments.iter().map(|s| s.ident.to_string()).collect();

            // UFCS calls: Config::get(provider, ...), HttpRequest::fetch(provider, ...) etc.
            if segments.len() >= 2 {
                let type_name = &segments[segments.len() - 2];
                let method_name = &segments[segments.len() - 1];
                if is_provider_trait(type_name) {
                    let line = path.span().start().line.saturating_sub(1);
                    let col_start = path.span().start().column;
                    let col_end = path.span().end().column;
                    self.used_traits.insert(type_name.clone());
                    self.trait_usages.push(TraitUsage {
                        trait_name: type_name.clone(),
                        method: method_name.clone(),
                        line,
                        col_range: (col_start, col_end),
                    });
                }
            }

            // Single-segment function calls for transitive resolution
            if segments.len() == 1 {
                self.called_functions.insert(segments[0].clone());
            }
        }

        syn::visit::visit_expr_call(self, call);
    }
}

/// Extract all Handler implementations from a parsed file.
fn extract_handlers(
    file: &syn::File, function_map: &HashMap<String, FunctionInfo>,
) -> Vec<HandlerInfo> {
    let mut handlers = Vec::new();

    for item in &file.items {
        let Item::Impl(impl_block) = item else {
            continue;
        };

        // Check if this implements a trait ending in "Handler"
        let Some((_, trait_path, _)) = &impl_block.trait_ else {
            continue;
        };
        if last_segment_name(trait_path) != "Handler" {
            continue;
        }

        let request_type = type_name(&impl_block.self_ty);
        let declared_bounds = extract_provider_bounds(&impl_block.generics);

        // Walk the impl body for trait usage and function calls
        let mut visitor = TraitUsageVisitor::default();
        visitor.collect_awaited_spans(&impl_block.items);
        for impl_item in &impl_block.items {
            visitor.visit_impl_item(impl_item);
        }

        let used_traits = resolve_transitive_traits(
            &visitor.used_traits,
            &visitor.called_functions,
            function_map,
        );

        let impl_line = impl_block.impl_token.span.start().line.saturating_sub(1);
        let end_line = impl_block
            .brace_token
            .span
            .close()
            .end()
            .line
            .saturating_sub(1);

        handlers.push(HandlerInfo {
            request_type,
            impl_line,
            declared_bounds,
            used_traits,
            direct_trait_usage: visitor.used_traits,
            called_functions: visitor.called_functions,
            line_range: (impl_line, end_line),
        });
    }

    handlers
}

/// Check if a function signature has a parameter named `provider` or `ctx`.
fn has_provider_param(sig: &syn::Signature) -> bool {
    for arg in &sig.inputs {
        if let syn::FnArg::Typed(pat_type) = arg
            && let syn::Pat::Ident(pat_ident) = pat_type.pat.as_ref()
        {
            let name = pat_ident.ident.to_string();
            if name == "provider" || name == "ctx" {
                return true;
            }
        }
    }
    false
}

/// Extract all helper functions with provider bounds from a parsed file.
fn extract_functions(file: &syn::File) -> HashMap<String, FunctionInfo> {
    let mut map = HashMap::new();

    for item in &file.items {
        let Item::Fn(func) = item else { continue };

        let bounds = extract_provider_bounds(&func.sig.generics);
        if bounds.is_empty() && !has_provider_param(&func.sig) {
            continue;
        }

        let mut visitor = TraitUsageVisitor::default();
        visitor.collect_awaited_spans_from_block(&func.block);
        visitor.visit_block(&func.block);

        let line = func.sig.fn_token.span.start().line.saturating_sub(1);
        let end_line = func
            .block
            .brace_token
            .span
            .close()
            .end()
            .line
            .saturating_sub(1);

        map.insert(
            func.sig.ident.to_string(),
            FunctionInfo {
                name: func.sig.ident.to_string(),
                line,
                declared_bounds: bounds,
                direct_trait_usage: visitor.used_traits,
                called_functions: visitor.called_functions,
                line_range: (line, end_line),
            },
        );
    }

    map
}

/// Collect all trait usages from the AST for reporting.
fn collect_trait_usages_from_file(file: &syn::File) -> HashMap<String, Vec<TraitUsage>> {
    let mut visitor = TraitUsageVisitor::default();

    // Collect awaited spans from all functions and impl blocks
    for item in &file.items {
        match item {
            Item::Fn(func) => {
                visitor.collect_awaited_spans_from_block(&func.block);
            }
            Item::Impl(impl_block) => {
                visitor.collect_awaited_spans(&impl_block.items);
            }
            _ => {}
        }
    }

    // Now visit everything
    for item in &file.items {
        visitor.visit_item(item);
    }

    let mut usages: HashMap<String, Vec<TraitUsage>> = HashMap::new();
    for usage in visitor.trait_usages {
        usages
            .entry(usage.trait_name.clone())
            .or_default()
            .push(usage);
    }
    usages
}

// ---------------------------------------------------------------------------
// Analysis logic (unchanged from regex era)
// ---------------------------------------------------------------------------

/// Resolve transitive trait requirements through function delegation.
/// Traverses the call graph to find all traits that are transitively required.
fn resolve_transitive_traits(
    direct_usage: &HashSet<String>, called_functions: &HashSet<String>,
    function_map: &HashMap<String, FunctionInfo>,
) -> HashSet<String> {
    let mut all_traits = direct_usage.clone();
    let mut visited = HashSet::new();
    let mut to_visit: Vec<String> = called_functions.iter().cloned().collect();

    while let Some(fn_name) = to_visit.pop() {
        if visited.contains(&fn_name) {
            continue;
        }
        visited.insert(fn_name.clone());

        if let Some(fn_info) = function_map.get(&fn_name) {
            all_traits.extend(fn_info.declared_bounds.iter().cloned());
            all_traits.extend(fn_info.direct_trait_usage.iter().cloned());

            for called in &fn_info.called_functions {
                if !visited.contains(called) {
                    to_visit.push(called.clone());
                }
            }
        }
    }

    all_traits
}

// ---------------------------------------------------------------------------
// SemanticAnalyzer (public API)
// ---------------------------------------------------------------------------

/// Semantic analyzer for Omnia code.
///
/// Uses `syn` for AST-based extraction and regex for simple text-pattern
/// checks (StateStore TTL, Config error handling, fetch context).
pub struct SemanticAnalyzer;

impl SemanticAnalyzer {
    /// Create a new semantic analyzer.
    pub fn new() -> Self {
        Self
    }

    /// Perform semantic analysis on the given content.
    pub fn analyze(&self, content: &str) -> SemanticAnalysisResult {
        let file = match syn::parse_file(content) {
            Ok(f) => f,
            Err(_) => return SemanticAnalysisResult::default(),
        };

        let mut result = SemanticAnalysisResult::default();

        let function_map = extract_functions(&file);
        let handlers = extract_handlers(&file, &function_map);

        for handler in &handlers {
            result
                .diagnostics
                .extend(self.check_unused_bounds(handler, content));
            result
                .diagnostics
                .extend(self.check_missing_bounds(handler, content));

            // Handler with no provider bounds at all
            if handler.declared_bounds.is_empty() {
                let lines: Vec<&str> = content.lines().collect();
                result.diagnostics.push(Diagnostic {
                    line: handler.impl_line + 1,
                    column: 0,
                    end_column: lines.get(handler.impl_line).map_or(0, |l| l.len()),
                    severity: RuleSeverity::Warning,
                    rule_id: "handler_missing_bounds".to_string(),
                    rule_name: "Handler Missing Provider Bounds".to_string(),
                    category: RuleCategory::Handler,
                    message: "Handler implementation should specify provider trait bounds."
                        .to_string(),
                    fix_template: Some(
                        "impl<P: Config + HttpRequest> Handler<P> for ...".to_string(),
                    ),
                    source_snippet: lines.get(handler.impl_line).map(|s| s.to_string()),
                });
            }
        }

        result.handlers = handlers;
        result.trait_usages = collect_trait_usages_from_file(&file);

        // Regex-based pattern checks (pragmatic hybrid -- these scan raw text)
        result
            .diagnostics
            .extend(self.analyze_trait_patterns(content, &function_map));

        result
    }

    /// Check for unused trait bounds in a handler.
    fn check_unused_bounds(&self, handler: &HandlerInfo, content: &str) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();
        let lines: Vec<&str> = content.lines().collect();

        for declared in &handler.declared_bounds {
            if !handler.used_traits.contains(declared) {
                diagnostics.push(Diagnostic {
                    line: handler.impl_line + 1,
                    column: 0,
                    end_column: lines.get(handler.impl_line).map_or(0, |l| l.len()),
                    severity: RuleSeverity::Warning,
                    rule_id: "unused_provider_bound".to_string(),
                    rule_name: "Unused Provider Trait Bound".to_string(),
                    category: RuleCategory::Provider,
                    message: format!(
                        "Provider trait '{}' is declared but never used in handler '{}'.\n\nRemove unused trait from bounds to improve clarity.",
                        declared, handler.request_type
                    ),
                    fix_template: Some(format!("Remove '{}' from provider bounds", declared)),
                    source_snippet: lines.get(handler.impl_line).map(|s| s.to_string()),
                });
            }
        }

        diagnostics
    }

    /// Check for missing trait bounds in a handler.
    fn check_missing_bounds(&self, handler: &HandlerInfo, content: &str) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();
        let lines: Vec<&str> = content.lines().collect();

        for used in &handler.used_traits {
            if !handler.declared_bounds.contains(used) {
                diagnostics.push(Diagnostic {
                    line: handler.impl_line + 1,
                    column: 0,
                    end_column: lines.get(handler.impl_line).map_or(0, |l| l.len()),
                    severity: RuleSeverity::Error,
                    rule_id: "missing_provider_bound".to_string(),
                    rule_name: "Missing Provider Trait Bound".to_string(),
                    category: RuleCategory::Provider,
                    message: format!(
                        "Handler '{}' uses trait '{}' but doesn't declare it in bounds.\n\nAdd '{}' to the provider bounds.",
                        handler.request_type, used, used
                    ),
                    fix_template: Some(format!("Add '{}' to provider bounds", used)),
                    source_snippet: lines.get(handler.impl_line).map(|s| s.to_string()),
                });
            }
        }

        diagnostics
    }

    /// Analyze trait usage patterns for additional diagnostics.
    /// Uses regex for simple text-pattern checks that don't benefit from AST parsing.
    fn analyze_trait_patterns(
        &self, content: &str, function_map: &HashMap<String, FunctionInfo>,
    ) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();
        let lines: Vec<&str> = content.lines().collect();

        let config_get_re =
            Regex::new(r"provider\.get\s*\([^)]+\)").expect("valid regex: config_get");
        for (line_idx, line) in lines.iter().enumerate() {
            if config_get_re.is_match(line)
                && !line.contains("unwrap_or")
                && !line.contains("ok_or")
                && !line.contains('?')
                && !line.contains(".await?")
            {
                diagnostics.push(Diagnostic {
                    line: line_idx + 1,
                    column: 0,
                    end_column: line.len(),
                    severity: RuleSeverity::Hint,
                    rule_id: "config_error_handling".to_string(),
                    rule_name: "Config::get Error Handling".to_string(),
                    category: RuleCategory::Error,
                    message: "Config::get returns Result - consider using `?` or `.ok_or_else(|| bad_request!(\"missing config\"))?`".to_string(),
                    fix_template: Some("Add `?` or proper error handling".to_string()),
                    source_snippet: Some(line.to_string()),
                });
            }
        }

        let set_no_ttl_re =
            Regex::new(r"provider\.set\s*\([^,]+,[^,]+,\s*None\s*\)").expect("valid regex: set_no_ttl");
        for (line_idx, line) in lines.iter().enumerate() {
            if set_no_ttl_re.is_match(line) {
                diagnostics.push(Diagnostic {
                    line: line_idx + 1,
                    column: 0,
                    end_column: line.len(),
                    severity: RuleSeverity::Warning,
                    rule_id: "statestore_no_ttl".to_string(),
                    rule_name: "StateStore::set Without TTL".to_string(),
                    category: RuleCategory::Caching,
                    message: "StateStore::set with None TTL - consider adding a TTL to prevent unbounded cache growth.\n\nExample: `Some(Duration::from_secs(3600))`".to_string(),
                    fix_template: Some("Some(Duration::from_secs(3600))".to_string()),
                    source_snippet: Some(line.to_string()),
                });
            }
        }

        let fetch_re =
            Regex::new(r"provider\.fetch\s*\([^)]+\)\.await\?").expect("valid regex: fetch_context");
        for (line_idx, line) in lines.iter().enumerate() {
            if fetch_re.is_match(line) && !line.contains(".context(") {
                diagnostics.push(Diagnostic {
                    line: line_idx + 1,
                    column: 0,
                    end_column: line.len(),
                    severity: RuleSeverity::Hint,
                    rule_id: "fetch_error_context".to_string(),
                    rule_name: "HttpRequest::fetch Error Context".to_string(),
                    category: RuleCategory::Error,
                    message: "Consider adding `.context(\"fetching from API\")` for better error messages.".to_string(),
                    fix_template: Some("Add `.context(\"description\")` before `?`".to_string()),
                    source_snippet: Some(line.to_string()),
                });
            }
        }

        self.check_function_trait_bounds(content, function_map, &mut diagnostics);

        diagnostics
    }

    /// Check helper functions for proper trait bounds.
    fn check_function_trait_bounds(
        &self, content: &str, function_map: &HashMap<String, FunctionInfo>,
        diagnostics: &mut Vec<Diagnostic>,
    ) {
        let lines: Vec<&str> = content.lines().collect();

        for fn_info in function_map.values() {
            let line = lines.get(fn_info.line).copied().unwrap_or("");

            let used_traits = resolve_transitive_traits(
                &fn_info.direct_trait_usage,
                &fn_info.called_functions,
                function_map,
            );

            for declared in &fn_info.declared_bounds {
                if !used_traits.contains(declared) {
                    diagnostics.push(Diagnostic {
                        line: fn_info.line + 1,
                        column: 0,
                        end_column: line.len(),
                        severity: RuleSeverity::Warning,
                        rule_id: "unused_fn_provider_bound".to_string(),
                        rule_name: "Unused Function Provider Trait Bound".to_string(),
                        category: RuleCategory::Provider,
                        message: format!(
                            "Unused provider trait bound `{}` in function `{}`.\n\nConsider removing it to keep bounds minimal.",
                            declared, fn_info.name
                        ),
                        fix_template: Some(format!("Remove '{}' from function bounds", declared)),
                        source_snippet: Some(line.to_string()),
                    });
                }
            }

            for used in &used_traits {
                if !fn_info.declared_bounds.contains(used) && !fn_info.declared_bounds.is_empty() {
                    diagnostics.push(Diagnostic {
                        line: fn_info.line + 1,
                        column: 0,
                        end_column: line.len(),
                        severity: RuleSeverity::Error,
                        rule_id: "missing_fn_provider_bound".to_string(),
                        rule_name: "Missing Function Provider Trait Bound".to_string(),
                        category: RuleCategory::Provider,
                        message: format!(
                            "Missing provider trait bound `{}` in function `{}`.\n\nThe function uses `{}` methods but doesn't declare it in bounds.",
                            used, fn_info.name, used
                        ),
                        fix_template: Some(format!("Add '{}' to function bounds", used)),
                        source_snippet: Some(line.to_string()),
                    });
                }
            }
        }
    }
}

impl Default for SemanticAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_find_handler_implementations() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
impl<P: Config + HttpRequest> Handler<P> for MyRequest {
    type Error = Error;
    type Input = Vec<u8>;
    type Output = MyResponse;

    fn from_input(input: Self::Input) -> Result<Self> {
        Ok(Self {})
    }

    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let url = ctx.provider.get("API_URL")?;
        let response = ctx.provider.fetch(request).await?;
        Ok(Reply::ok(MyResponse {}))
    }
}
"#;
        let result = analyzer.analyze(content);
        assert_eq!(result.handlers.len(), 1);

        let handler = &result.handlers[0];
        assert_eq!(handler.request_type, "MyRequest");
        assert!(handler.declared_bounds.contains("Config"));
        assert!(handler.declared_bounds.contains("HttpRequest"));
        assert!(handler.used_traits.contains("Config"));
        assert!(handler.used_traits.contains("HttpRequest"));
    }

    #[test]
    fn test_detect_unused_bounds() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
impl<P: Config + HttpRequest + Publisher> Handler<P> for MyRequest {
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let url = ctx.provider.get("API_URL")?;
        Ok(Reply::ok(MyResponse {}))
    }
}
"#;
        let result = analyzer.analyze(content);

        let unused_warnings: Vec<_> =
            result.diagnostics.iter().filter(|d| d.rule_id == "unused_provider_bound").collect();

        assert!(unused_warnings.len() >= 1);
    }

    #[test]
    fn test_detect_missing_bounds() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
impl<P: Config> Handler<P> for CacheRequest {
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let cached = ctx.provider.get("key").await?;
        Ok(Reply::ok(cached))
    }
}
"#;
        let result = analyzer.analyze(content);

        let missing_errors: Vec<_> =
            result.diagnostics.iter().filter(|d| d.rule_id == "missing_provider_bound").collect();

        assert!(missing_errors.len() >= 1);
    }

    #[test]
    fn test_transitive_trait_detection_via_function_delegation() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
async fn fetch_data<P: HttpRequest>(provider: &P, url: &str) -> Result<Response> {
    provider.fetch(url).await
}

impl<P: Config + HttpRequest> Handler<P> for DelegatingRequest {
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let url = ctx.provider.get("API_URL")?;
        let response = fetch_data(&ctx.provider, &url).await?;
        Ok(Reply::ok(response))
    }
}
"#;
        let result = analyzer.analyze(content);

        let handler = &result.handlers[0];

        assert!(
            handler.used_traits.contains("HttpRequest"),
            "HttpRequest should be detected via transitive delegation to fetch_data"
        );

        let unused_http: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.rule_id == "unused_provider_bound" && d.message.contains("HttpRequest"))
            .collect();

        assert!(
            unused_http.is_empty(),
            "HttpRequest should not be flagged as unused when used transitively: {:?}",
            unused_http
        );
    }

    #[test]
    fn test_transitive_trait_detection_chain() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
async fn send_notification<P: Publisher>(provider: &P, msg: &str) -> Result<()> {
    provider.send(msg).await
}

async fn notify_users<P: Publisher>(provider: &P) -> Result<()> {
    send_notification(provider, "Hello").await
}

impl<P: Config + Publisher> Handler<P> for ChainedRequest {
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let _ = ctx.provider.get("NOTIFY")?;
        notify_users(&ctx.provider).await?;
        Ok(Reply::ok(()))
    }
}
"#;
        let result = analyzer.analyze(content);

        let handler = &result.handlers[0];

        assert!(
            handler.used_traits.contains("Publisher"),
            "Publisher should be detected via chained delegation: notify_users -> send_notification"
        );

        let unused_pub: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.rule_id == "unused_provider_bound" && d.message.contains("Publisher"))
            .collect();

        assert!(
            unused_pub.is_empty(),
            "Publisher should not be flagged as unused when used in delegation chain"
        );
    }

    #[test]
    fn test_analyze_statestore_no_ttl() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
async fn cache_it<P: StateStore>(provider: &P) -> Result<()> {
    provider.set("key", b"value", None).await?;
    Ok(())
}
"#;
        let result = analyzer.analyze(content);
        let ttl_warnings: Vec<_> =
            result.diagnostics.iter().filter(|d| d.rule_id == "statestore_no_ttl").collect();
        assert!(
            !ttl_warnings.is_empty(),
            "Should warn about StateStore::set with None TTL"
        );
    }

    #[test]
    fn test_extract_provider_bounds_inline() {
        let generics: syn::Generics = syn::parse_str("< P : Config + HttpRequest >").unwrap();
        let bounds = extract_provider_bounds(&generics);
        assert!(bounds.contains("Config"));
        assert!(bounds.contains("HttpRequest"));
        assert_eq!(bounds.len(), 2);
    }

    #[test]
    fn test_extract_provider_bounds_where_clause() {
        let item: syn::ItemFn = syn::parse_str(
            "fn foo<P>() where P: Config + StateStore {}",
        )
        .unwrap();
        let bounds = extract_provider_bounds(&item.sig.generics);
        assert!(bounds.contains("Config"));
        assert!(bounds.contains("StateStore"));
    }

    #[test]
    fn test_extract_provider_bounds_filters_non_provider() {
        let generics: syn::Generics =
            syn::parse_str("< P : Config + Send + Sync + Debug >").unwrap();
        let bounds = extract_provider_bounds(&generics);
        assert!(bounds.contains("Config"));
        assert!(!bounds.contains("Send"));
        assert!(!bounds.contains("Debug"));
        assert_eq!(bounds.len(), 1);
    }

    #[test]
    fn test_graceful_fallback_on_invalid_syntax() {
        let analyzer = SemanticAnalyzer::new();
        let content = "this is not valid rust {{{{";
        let result = analyzer.analyze(content);
        assert!(result.handlers.is_empty());
        assert!(result.diagnostics.is_empty());
    }

    #[test]
    fn test_handler_missing_bounds_diagnostic() {
        let analyzer = SemanticAnalyzer::new();
        let content = r#"
impl<P> Handler<P> for NoBoundsRequest {
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        Ok(Reply::ok(()))
    }
}
"#;
        let result = analyzer.analyze(content);
        let missing: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.rule_id == "handler_missing_bounds")
            .collect();
        assert!(
            !missing.is_empty(),
            "Should warn about handler with no provider bounds"
        );
    }
}
