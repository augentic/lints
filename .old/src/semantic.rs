//! Semantic analysis for QWASR code.
//!
//! This module provides deeper code analysis beyond simple pattern matching,
//! including:
//! - Provider trait bound analysis (detecting unused or missing bounds)
//! - Trait usage tracking
//! - Handler implementation validation

use std::collections::{HashMap, HashSet};
use std::sync::Arc;

use regex::Regex;
use tower_lsp::lsp_types::*;

use crate::qwasr::QwasrContext;

/// Result of semantic analysis for a document.
#[derive(Debug, Default)]
pub struct SemanticAnalysisResult {
    /// Diagnostics generated by semantic analysis.
    pub diagnostics: Vec<Diagnostic>,

    /// Handler implementations found in the document.
    pub handlers: Vec<HandlerInfo>,

    /// Provider trait usages detected.
    pub trait_usages: HashMap<String, Vec<TraitUsage>>,
}

/// Information about a Handler implementation.
#[derive(Debug, Clone)]
pub struct HandlerInfo {
    /// Name of the request type implementing Handler.
    pub request_type: String,

    /// Line number where the impl block starts.
    pub impl_line: u32,

    /// Provider trait bounds declared on the impl.
    pub declared_bounds: HashSet<String>,

    /// Provider traits actually used in the handler body.
    pub used_traits: HashSet<String>,

    /// Line range of the impl block.
    #[allow(dead_code)]
    pub line_range: (u32, u32),
}

/// A detected usage of a provider trait.
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct TraitUsage {
    /// Name of the trait used.
    pub trait_name: String,

    /// Method called on the trait.
    pub method: String,

    /// Line number where the usage occurs.
    pub line: u32,

    /// Column range of the usage.
    pub col_range: (u32, u32),
}

/// Semantic analyzer for QWASR code.
pub struct SemanticAnalyzer {
    /// QWASR context with known patterns.
    #[allow(dead_code)]
    context: Arc<QwasrContext>,

    /// Regex for detecting Handler impl blocks.
    handler_impl_re: Regex,

    /// Regex for extracting provider bounds.
    bounds_re: Regex,

    /// Regex for detecting where clause bounds.
    where_bounds_re: Regex,

    /// Provider trait method patterns for usage detection.
    trait_method_patterns: Vec<TraitMethodPattern>,
}

/// Pattern for detecting trait method usage.
struct TraitMethodPattern {
    trait_name: &'static str,
    methods: Vec<&'static str>,
    patterns: Vec<Regex>,
}

impl SemanticAnalyzer {
    /// Create a new semantic analyzer.
    pub fn new(context: Arc<QwasrContext>) -> Self {
        let trait_method_patterns = vec![
            TraitMethodPattern {
                trait_name: "Config",
                methods: vec!["get"],
                patterns: vec![
                    Regex::new(r#"(?:ctx\.)?provider\.get\s*\(\s*"[^"]+"\s*\)"#).unwrap(),
                    Regex::new(r#"Config::get\s*\("#).unwrap(),
                    Regex::new(r#"\.get\s*\(\s*"[A-Z_]+"\s*\)"#).unwrap(),
                ],
            },
            TraitMethodPattern {
                trait_name: "HttpRequest",
                methods: vec!["fetch"],
                patterns: vec![
                    Regex::new(r"(?:ctx\.)?provider\.fetch\s*\(").unwrap(),
                    Regex::new(r"HttpRequest::fetch\s*\(").unwrap(),
                ],
            },
            TraitMethodPattern {
                trait_name: "Publisher",
                methods: vec!["send"],
                patterns: vec![
                    Regex::new(r"(?:ctx\.)?provider\.send\s*\(").unwrap(),
                    Regex::new(r"Publisher::send\s*\(").unwrap(),
                ],
            },
            TraitMethodPattern {
                trait_name: "StateStore",
                methods: vec!["get", "set", "delete"],
                patterns: vec![
                    // StateStore::get/set/delete patterns
                    Regex::new(r"StateStore::(?:get|set|delete)\s*\(").unwrap(),
                    // ctx.provider.get/set/delete with await (StateStore methods)
                    Regex::new(r"(?:ctx\.)?provider\.(?:get|set|delete)\s*\([^)]*\)\.await")
                        .unwrap(),
                ],
            },
            TraitMethodPattern {
                trait_name: "Identity",
                methods: vec!["access_token"],
                patterns: vec![
                    Regex::new(r"(?:ctx\.)?provider\.access_token\s*\(").unwrap(),
                    Regex::new(r"Identity::access_token\s*\(").unwrap(),
                ],
            },
            TraitMethodPattern {
                trait_name: "TableStore",
                methods: vec!["query", "exec"],
                patterns: vec![
                    Regex::new(r"(?:ctx\.)?provider\.query\s*\(").unwrap(),
                    Regex::new(r"(?:ctx\.)?provider\.exec\s*\(").unwrap(),
                    Regex::new(r"TableStore::(?:query|exec)\s*\(").unwrap(),
                ],
            },
        ];

        Self {
            context,
            handler_impl_re: Regex::new(
                r"impl\s*<\s*P\s*(?::\s*([^>]+))?\s*>\s*Handler\s*<\s*P\s*>\s*for\s+(\w+)",
            )
            .unwrap(),
            bounds_re: Regex::new(r"(\w+)(?:\s*\+\s*|\s*,|\s*$)").unwrap(),
            // Match where clause with P bounds, handling multi-line format
            where_bounds_re: Regex::new(r"(?s)where\s+P\s*:\s*([^{]+?)\s*\{").unwrap(),
            trait_method_patterns,
        }
    }

    /// Perform semantic analysis on the given content.
    pub fn analyze(&self, content: &str) -> SemanticAnalysisResult {
        let mut result = SemanticAnalysisResult::default();

        // Find all handler implementations
        let handlers = self.find_handler_implementations(content);

        // Analyze each handler for trait bound issues
        for handler in &handlers {
            // Check for unused trait bounds
            result
                .diagnostics
                .extend(self.check_unused_bounds(handler, content));

            // Check for missing trait bounds
            result
                .diagnostics
                .extend(self.check_missing_bounds(handler, content));
        }

        result.handlers = handlers;

        // Collect all trait usages
        result.trait_usages = self.collect_trait_usages(content);

        // Add diagnostics for trait usage patterns
        result
            .diagnostics
            .extend(self.analyze_trait_patterns(content));

        result
    }

    /// Find all Handler implementations in the content.
    fn find_handler_implementations(&self, content: &str) -> Vec<HandlerInfo> {
        let mut handlers = Vec::new();
        let lines: Vec<&str> = content.lines().collect();

        for (line_idx, line) in lines.iter().enumerate() {
            if let Some(caps) = self.handler_impl_re.captures(line) {
                let request_type = caps
                    .get(2)
                    .map(|m| m.as_str().to_string())
                    .unwrap_or_default();

                // Extract bounds from the impl line or where clause
                let mut declared_bounds = HashSet::new();

                // Check inline bounds (impl<P: Trait1 + Trait2>)
                if let Some(bounds_match) = caps.get(1) {
                    for bound_cap in self.bounds_re.captures_iter(bounds_match.as_str()) {
                        if let Some(bound) = bound_cap.get(1) {
                            let bound_name = bound.as_str();
                            if self.is_provider_trait(bound_name) {
                                declared_bounds.insert(bound_name.to_string());
                            }
                        }
                    }
                }

                // Look for where clause in the next few lines
                let context_lines: String = lines
                    .iter()
                    .skip(line_idx)
                    .take(10)
                    .cloned()
                    .collect::<Vec<_>>()
                    .join("\n");

                if let Some(where_caps) = self.where_bounds_re.captures(&context_lines) {
                    if let Some(where_bounds) = where_caps.get(1) {
                        for bound_cap in self.bounds_re.captures_iter(where_bounds.as_str()) {
                            if let Some(bound) = bound_cap.get(1) {
                                let bound_name = bound.as_str();
                                if self.is_provider_trait(bound_name) {
                                    declared_bounds.insert(bound_name.to_string());
                                }
                            }
                        }
                    }
                }

                // Find the end of the impl block
                let impl_end = self.find_impl_block_end(&lines, line_idx);

                // Extract the impl block content
                let impl_content: String = lines
                    .iter()
                    .skip(line_idx)
                    .take(impl_end - line_idx + 1)
                    .cloned()
                    .collect::<Vec<_>>()
                    .join("\n");

                // Detect used traits in the impl block
                let used_traits = self.detect_trait_usage(&impl_content);

                handlers.push(HandlerInfo {
                    request_type,
                    impl_line: line_idx as u32,
                    declared_bounds,
                    used_traits,
                    line_range: (line_idx as u32, impl_end as u32),
                });
            }
        }

        handlers
    }

    /// Check if a name is a known provider trait.
    fn is_provider_trait(&self, name: &str) -> bool {
        matches!(
            name,
            "Config" | "HttpRequest" | "Publisher" | "StateStore" | "Identity" | "TableStore"
        )
    }

    /// Find the end of an impl block by counting braces.
    fn find_impl_block_end(&self, lines: &[&str], start_line: usize) -> usize {
        let mut brace_count = 0;
        let mut found_first_brace = false;

        for (idx, line) in lines.iter().enumerate().skip(start_line) {
            for ch in line.chars() {
                if ch == '{' {
                    brace_count += 1;
                    found_first_brace = true;
                } else if ch == '}' {
                    brace_count -= 1;
                    if found_first_brace && brace_count == 0 {
                        return idx;
                    }
                }
            }
        }

        lines.len().saturating_sub(1)
    }

    /// Detect which provider traits are used in a code block.
    fn detect_trait_usage(&self, content: &str) -> HashSet<String> {
        let mut used_traits = HashSet::new();

        for pattern in &self.trait_method_patterns {
            for regex in &pattern.patterns {
                if regex.is_match(content) {
                    used_traits.insert(pattern.trait_name.to_string());
                    break;
                }
            }
        }

        used_traits
    }

    /// Check for unused provider trait bounds.
    fn check_unused_bounds(&self, handler: &HandlerInfo, _content: &str) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();

        for declared in &handler.declared_bounds {
            if !handler.used_traits.contains(declared) {
                // Calculate the fix: remove the unused trait from bounds
                let new_bounds: Vec<_> = handler
                    .declared_bounds
                    .iter()
                    .filter(|b| *b != declared)
                    .cloned()
                    .collect();

                let fix_text = if new_bounds.is_empty() {
                    format!("impl<P> Handler<P> for {}", handler.request_type)
                } else {
                    format!(
                        "impl<P: {}> Handler<P> for {}",
                        new_bounds.join(" + "),
                        handler.request_type
                    )
                };

                // Store fix data as JSON in the diagnostic
                let fix_data = serde_json::json!({
                    "fix_type": "remove_unused_bound",
                    "unused_trait": declared,
                    "new_impl_signature": fix_text,
                    "request_type": handler.request_type,
                    "remaining_bounds": new_bounds,
                });

                diagnostics.push(Diagnostic {
                    range: Range {
                        start: Position {
                            line: handler.impl_line,
                            character: 0,
                        },
                        end: Position {
                            line: handler.impl_line,
                            character: 200,
                        },
                    },
                    severity: Some(DiagnosticSeverity::WARNING),
                    code: Some(NumberOrString::String("unused_provider_bound".to_string())),
                    source: Some("qwasr".to_string()),
                    message: format!(
                        "Unused provider trait bound: `{}`\n\n\
                        The `{}` trait is declared in the bounds for `{}` but is never used in the handler.\n\n\
                        Consider removing it to keep bounds minimal:\n\
                        `{}`",
                        declared,
                        declared,
                        handler.request_type,
                        fix_text
                    ),
                    tags: Some(vec![DiagnosticTag::UNNECESSARY]),
                    data: Some(fix_data),
                    ..Default::default()
                });
            }
        }

        diagnostics
    }

    /// Check for missing provider trait bounds.
    fn check_missing_bounds(&self, handler: &HandlerInfo, _content: &str) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();

        for used in &handler.used_traits {
            if !handler.declared_bounds.contains(used) {
                // Calculate the fix: add the missing trait to bounds
                let mut new_bounds: Vec<_> = handler.declared_bounds.iter().cloned().collect();
                new_bounds.push(used.clone());
                new_bounds.sort(); // Keep bounds in consistent order

                let fix_text = format!(
                    "impl<P: {}> Handler<P> for {}",
                    new_bounds.join(" + "),
                    handler.request_type
                );

                // Store fix data as JSON in the diagnostic
                let fix_data = serde_json::json!({
                    "fix_type": "add_missing_bound",
                    "missing_trait": used,
                    "new_impl_signature": fix_text,
                    "request_type": handler.request_type,
                    "all_bounds": new_bounds,
                });

                diagnostics.push(Diagnostic {
                    range: Range {
                        start: Position {
                            line: handler.impl_line,
                            character: 0,
                        },
                        end: Position {
                            line: handler.impl_line,
                            character: 200,
                        },
                    },
                    severity: Some(DiagnosticSeverity::ERROR),
                    code: Some(NumberOrString::String("missing_provider_bound".to_string())),
                    source: Some("qwasr".to_string()),
                    message: format!(
                        "Missing provider trait bound: `{}`\n\n\
                        The handler for `{}` uses `{}` methods but doesn't declare it in the bounds.\n\n\
                        Add the trait bound:\n\
                        `{}`",
                        used,
                        handler.request_type,
                        used,
                        fix_text
                    ),
                    data: Some(fix_data),
                    ..Default::default()
                });
            }
        }

        diagnostics
    }

    /// Collect all trait usages in the document.
    fn collect_trait_usages(&self, content: &str) -> HashMap<String, Vec<TraitUsage>> {
        let mut usages: HashMap<String, Vec<TraitUsage>> = HashMap::new();

        for (line_idx, line) in content.lines().enumerate() {
            for pattern in &self.trait_method_patterns {
                for (method_idx, regex) in pattern.patterns.iter().enumerate() {
                    for mat in regex.find_iter(line) {
                        let method = if method_idx < pattern.methods.len() {
                            pattern.methods[method_idx]
                        } else {
                            pattern.methods.first().copied().unwrap_or("unknown")
                        };

                        let usage = TraitUsage {
                            trait_name: pattern.trait_name.to_string(),
                            method: method.to_string(),
                            line: line_idx as u32,
                            col_range: (mat.start() as u32, mat.end() as u32),
                        };

                        usages
                            .entry(pattern.trait_name.to_string())
                            .or_default()
                            .push(usage);
                    }
                }
            }
        }

        usages
    }

    /// Analyze trait usage patterns for potential issues.
    fn analyze_trait_patterns(&self, content: &str) -> Vec<Diagnostic> {
        let mut diagnostics = Vec::new();
        let lines: Vec<&str> = content.lines().collect();

        // Check for Config usage without error handling
        // Use simple pattern matching instead of lookahead
        let config_get_re = Regex::new(r"provider\.get\s*\([^)]+\)").unwrap();
        for (line_idx, line) in lines.iter().enumerate() {
            if config_get_re.is_match(line)
                && !line.contains("unwrap_or")
                && !line.contains("ok_or")
            {
                // Check if there's a ? on the same line or the config value is used with ?
                if !line.contains('?') && !line.contains(".await?") {
                    diagnostics.push(Diagnostic {
                        range: Range {
                            start: Position {
                                line: line_idx as u32,
                                character: 0,
                            },
                            end: Position {
                                line: line_idx as u32,
                                character: line.len() as u32,
                            },
                        },
                        severity: Some(DiagnosticSeverity::HINT),
                        code: Some(NumberOrString::String("config_error_handling".to_string())),
                        source: Some("qwasr".to_string()),
                        message: "Config::get returns Result - consider using `?` or `.ok_or_else(|| bad_request!(\"missing config\"))?`".to_string(),
                        ..Default::default()
                    });
                }
            }
        }

        // Check for StateStore set without TTL consideration
        let set_no_ttl_re = Regex::new(r"provider\.set\s*\([^,]+,[^,]+,\s*None\s*\)").unwrap();
        for (line_idx, line) in lines.iter().enumerate() {
            if set_no_ttl_re.is_match(line) {
                // Create fix: replace None with Some(Duration::from_secs(3600))
                let fixed_line = line.replace(", None)", ", Some(Duration::from_secs(3600)))");

                let fix_data = serde_json::json!({
                    "fix_type": "add_ttl",
                    "original_line": line,
                    "fixed_line": fixed_line,
                });

                diagnostics.push(Diagnostic {
                    range: Range {
                        start: Position {
                            line: line_idx as u32,
                            character: 0,
                        },
                        end: Position {
                            line: line_idx as u32,
                            character: line.len() as u32,
                        },
                    },
                    severity: Some(DiagnosticSeverity::WARNING),
                    code: Some(NumberOrString::String("statestore_no_ttl".to_string())),
                    source: Some("qwasr".to_string()),
                    message: "StateStore::set with None TTL - consider adding a TTL to prevent unbounded cache growth.\n\nExample: `Some(Duration::from_secs(3600))`".to_string(),
                    data: Some(fix_data),
                    ..Default::default()
                });
            }
        }

        // Check for HttpRequest fetch without proper error context
        // Use simple matching instead of lookahead (not supported by rust regex)
        let fetch_re = Regex::new(r"provider\.fetch\s*\([^)]+\)\.await\?").unwrap();
        for (line_idx, line) in lines.iter().enumerate() {
            if fetch_re.is_match(line) && !line.contains(".context(") {
                diagnostics.push(Diagnostic {
                    range: Range {
                        start: Position {
                            line: line_idx as u32,
                            character: 0,
                        },
                        end: Position {
                            line: line_idx as u32,
                            character: line.len() as u32,
                        },
                    },
                    severity: Some(DiagnosticSeverity::HINT),
                    code: Some(NumberOrString::String("fetch_error_context".to_string())),
                    source: Some("qwasr".to_string()),
                    message: "Consider adding `.context(\"fetching from API\")` for better error messages.".to_string(),
                    ..Default::default()
                });
            }
        }

        // Detect potential trait bound optimization
        self.check_function_trait_bounds(content, &mut diagnostics);

        diagnostics
    }

    /// Check helper functions for proper trait bounds.
    fn check_function_trait_bounds(&self, content: &str, diagnostics: &mut Vec<Diagnostic>) {
        let lines: Vec<&str> = content.lines().collect();

        // Pattern for async functions with provider parameter
        let fn_with_provider_re = Regex::new(
            r"(?:pub\s+)?async\s+fn\s+(\w+)\s*<\s*P\s*(?::\s*([^>]+))?\s*>\s*\([^)]*(?:provider|ctx)[^)]*\)"
        ).unwrap();

        for (line_idx, line) in lines.iter().enumerate() {
            if let Some(caps) = fn_with_provider_re.captures(line) {
                let fn_name = caps.get(1).map(|m| m.as_str()).unwrap_or("");

                // Get declared bounds
                let mut declared_bounds = HashSet::new();
                if let Some(bounds_match) = caps.get(2) {
                    for bound_cap in self.bounds_re.captures_iter(bounds_match.as_str()) {
                        if let Some(bound) = bound_cap.get(1) {
                            let bound_name = bound.as_str();
                            if self.is_provider_trait(bound_name) {
                                declared_bounds.insert(bound_name.to_string());
                            }
                        }
                    }
                }

                // Look for where clause
                let context_lines: String = lines
                    .iter()
                    .skip(line_idx)
                    .take(5)
                    .cloned()
                    .collect::<Vec<_>>()
                    .join("\n");

                if let Some(where_caps) = self.where_bounds_re.captures(&context_lines) {
                    if let Some(where_bounds) = where_caps.get(1) {
                        for bound_cap in self.bounds_re.captures_iter(where_bounds.as_str()) {
                            if let Some(bound) = bound_cap.get(1) {
                                let bound_name = bound.as_str();
                                if self.is_provider_trait(bound_name) {
                                    declared_bounds.insert(bound_name.to_string());
                                }
                            }
                        }
                    }
                }

                // Find function body and detect usage
                let fn_end = self.find_fn_end(&lines, line_idx);
                let fn_content: String = lines
                    .iter()
                    .skip(line_idx)
                    .take(fn_end - line_idx + 1)
                    .cloned()
                    .collect::<Vec<_>>()
                    .join("\n");

                let used_traits = self.detect_trait_usage(&fn_content);

                // Report unused bounds in helper functions
                for declared in &declared_bounds {
                    if !used_traits.contains(declared) {
                        // Calculate fix: remove unused trait from bounds
                        let new_bounds: Vec<_> = declared_bounds
                            .iter()
                            .filter(|b| *b != declared)
                            .cloned()
                            .collect();

                        let new_signature = if new_bounds.is_empty() {
                            line.replace(&format!("<P: {}>", declared), "<P>")
                                .replace(&format!("<P: {} + ", declared), "<P: ")
                                .replace(&format!(" + {}>", declared), ">")
                        } else {
                            // Attempt a simple replacement
                            line.replace(&format!("{} + ", declared), "")
                                .replace(&format!(" + {}", declared), "")
                        };

                        let fix_data = serde_json::json!({
                            "fix_type": "remove_unused_fn_bound",
                            "unused_trait": declared,
                            "new_fn_signature": new_signature,
                            "fn_name": fn_name,
                        });

                        diagnostics.push(Diagnostic {
                            range: Range {
                                start: Position {
                                    line: line_idx as u32,
                                    character: 0,
                                },
                                end: Position {
                                    line: line_idx as u32,
                                    character: line.len() as u32,
                                },
                            },
                            severity: Some(DiagnosticSeverity::WARNING),
                            code: Some(NumberOrString::String(
                                "unused_fn_provider_bound".to_string(),
                            )),
                            source: Some("qwasr".to_string()),
                            message: format!(
                                "Unused provider trait bound `{}` in function `{}`.\n\n\
                                Consider removing it to keep bounds minimal.",
                                declared, fn_name
                            ),
                            tags: Some(vec![DiagnosticTag::UNNECESSARY]),
                            data: Some(fix_data),
                            ..Default::default()
                        });
                    }
                }

                // Report missing bounds
                for used in &used_traits {
                    if !declared_bounds.contains(used) && !declared_bounds.is_empty() {
                        // Calculate fix: add missing trait to bounds
                        let mut all_bounds: Vec<_> = declared_bounds.iter().cloned().collect();
                        all_bounds.push(used.clone());
                        all_bounds.sort();

                        // Find the bounds portion and add the new trait
                        let new_signature = if line.contains("<P:") {
                            // Has existing bounds, add to them
                            line.replace(
                                &format!(
                                    "<P: {}",
                                    declared_bounds.iter().next().unwrap_or(&String::new())
                                ),
                                &format!(
                                    "<P: {} + {}",
                                    used,
                                    declared_bounds.iter().next().unwrap_or(&String::new())
                                ),
                            )
                        } else if line.contains("<P>") {
                            // No bounds, add them
                            line.replace("<P>", &format!("<P: {}>", used))
                        } else {
                            line.to_string()
                        };

                        let fix_data = serde_json::json!({
                            "fix_type": "add_missing_fn_bound",
                            "missing_trait": used,
                            "new_fn_signature": new_signature,
                            "fn_name": fn_name,
                            "all_bounds": all_bounds,
                        });

                        diagnostics.push(Diagnostic {
                            range: Range {
                                start: Position {
                                    line: line_idx as u32,
                                    character: 0,
                                },
                                end: Position {
                                    line: line_idx as u32,
                                    character: line.len() as u32,
                                },
                            },
                            severity: Some(DiagnosticSeverity::ERROR),
                            code: Some(NumberOrString::String(
                                "missing_fn_provider_bound".to_string(),
                            )),
                            source: Some("qwasr".to_string()),
                            message: format!(
                                "Missing provider trait bound `{}` in function `{}`.\n\n\
                                The function uses `{}` methods but doesn't declare it in bounds.",
                                used, fn_name, used
                            ),
                            data: Some(fix_data),
                            ..Default::default()
                        });
                    }
                }
            }
        }
    }

    /// Find the end of a function by counting braces.
    fn find_fn_end(&self, lines: &[&str], start_line: usize) -> usize {
        let mut brace_count = 0;
        let mut found_first_brace = false;

        for (idx, line) in lines.iter().enumerate().skip(start_line) {
            for ch in line.chars() {
                if ch == '{' {
                    brace_count += 1;
                    found_first_brace = true;
                } else if ch == '}' {
                    brace_count -= 1;
                    if found_first_brace && brace_count == 0 {
                        return idx;
                    }
                }
            }
        }

        lines.len().saturating_sub(1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_analyzer() -> SemanticAnalyzer {
        SemanticAnalyzer::new(Arc::new(QwasrContext::new()))
    }

    #[test]
    fn test_detect_unused_bound() {
        let analyzer = create_analyzer();
        let content = r#"
impl<P: Config + HttpRequest> Handler<P> for MyRequest {
    type Error = Error;
    type Input = Vec<u8>;
    type Output = MyResponse;

    fn from_input(input: Self::Input) -> Result<Self> {
        serde_json::from_slice(&input).map_err(Into::into)
    }

    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        // Only uses Config, not HttpRequest
        let url = ctx.provider.get("API_URL")?;
        Ok(Reply::ok(MyResponse { url }))
    }
}
"#;

        let result = analyzer.analyze(content);
        assert!(!result.handlers.is_empty());

        let handler = &result.handlers[0];
        assert!(handler.declared_bounds.contains("Config"));
        assert!(handler.declared_bounds.contains("HttpRequest"));
        assert!(handler.used_traits.contains("Config"));
        assert!(!handler.used_traits.contains("HttpRequest"));

        // Should have an unused bound warning
        let unused_warnings: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| d.code == Some(NumberOrString::String("unused_provider_bound".to_string())))
            .collect();
        assert!(!unused_warnings.is_empty());
    }

    #[test]
    fn test_detect_missing_bound() {
        let analyzer = create_analyzer();
        let content = r#"
impl<P: Config> Handler<P> for MyRequest {
    type Error = Error;
    type Input = Vec<u8>;
    type Output = MyResponse;

    fn from_input(input: Self::Input) -> Result<Self> {
        serde_json::from_slice(&input).map_err(Into::into)
    }

    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let url = ctx.provider.get("API_URL")?;
        // Uses HttpRequest but not declared
        let response = ctx.provider.fetch(request).await?;
        Ok(Reply::ok(MyResponse { url }))
    }
}
"#;

        let result = analyzer.analyze(content);
        assert!(!result.handlers.is_empty());

        let handler = &result.handlers[0];
        assert!(handler.declared_bounds.contains("Config"));
        assert!(!handler.declared_bounds.contains("HttpRequest"));
        assert!(handler.used_traits.contains("HttpRequest"));

        // Should have a missing bound error
        let missing_errors: Vec<_> = result
            .diagnostics
            .iter()
            .filter(|d| {
                d.code == Some(NumberOrString::String("missing_provider_bound".to_string()))
            })
            .collect();
        assert!(!missing_errors.is_empty());
    }

    #[test]
    fn test_where_clause_bounds() {
        let analyzer = create_analyzer();
        let content = r#"
impl<P> Handler<P> for MyRequest
where
    P: Config + HttpRequest + Publisher,
{
    async fn handle(self, ctx: Context<'_, P>) -> Result<Reply<Self::Output>> {
        let url = ctx.provider.get("API_URL")?;
        let response = ctx.provider.fetch(request).await?;
        Ok(Reply::ok(MyResponse {}))
    }
}
"#;

        let result = analyzer.analyze(content);
        assert!(!result.handlers.is_empty());

        let handler = &result.handlers[0];
        assert!(handler.declared_bounds.contains("Config"));
        assert!(handler.declared_bounds.contains("HttpRequest"));
        assert!(handler.declared_bounds.contains("Publisher"));

        // Publisher is unused
        assert!(!handler.used_traits.contains("Publisher"));
    }

    #[test]
    fn test_trait_usage_collection() {
        let analyzer = create_analyzer();
        let content = r#"
async fn do_something<P: Config + HttpRequest>(provider: &P) -> Result<()> {
    let url = provider.get("URL")?;
    let response = provider.fetch(request).await?;
    Ok(())
}
"#;

        let result = analyzer.analyze(content);

        assert!(result.trait_usages.contains_key("Config"));
        assert!(result.trait_usages.contains_key("HttpRequest"));
    }
}
